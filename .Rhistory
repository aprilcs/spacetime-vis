library(plm)
data("Produc")
# combine this information, and de-select uneeded areas (DC here)
# deselect District of Columbia, polygon 8, which is not present in Produc:
Produc.st = STFDF(states[-8], time, Produc[order(Produc[2], Produc[1]),])
library(RColorBrewer)
library(spacetime)
windows()
stplot(Produc.st[,,"unemp"], yrs, col.regions = brewer.pal(9, "YlOrRd"),cuts=9)
# Interpolating wind in Ireland ####
library(gstat)
data("wind")
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y
proj4string(wind.loc) = "+proj=longlat +datum=WGS84"
wind[1:3,]
# recode the time columns to appropriate time data structure
wind$time = ISOdate(wind$year+1900, wind$month, wind$day)
wind$jday = as.numeric(format(wind$time, '%j' ))
# subtract a smooth trend of daily means
stations = 4:15
windsqrt = sqrt(0.5148 * as.matrix(wind[stations])) # knots -> m/s
Jday = 1:366
windsqrt = windsqrt - mean(windsqrt)
daymeans = sapply(split(windsqrt, wind$jday), mean)
meanwind = lowess(daymeans ~ Jday, f = 0.1)$y[wind$jday]
velocities = apply(windsqrt, 2, function(x) { x - meanwind })
# match the wind data to its location, by connecting town names to location coordinates ####
# Create a spatial points object ####
wind.loc = wind.loc[match(names(wind[4:15]), wind.loc$Code),]
pts = coordinates(wind.loc[match(names(wind[4:15]), wind.loc$Code),])
rownames(pts) = wind.loc$Station
pts = SpatialPoints(pts, CRS("+proj=longlat +datum=WGS84"))
# project to UTM zone 29 ####
library(rgdal)
utm29 = CRS("+proj=utm +zone=29 +datum=WGS84")
pts = spTransform(pts, utm29)
# Construct spatio-temporal object from the space-wide table with velocities ####
wind.data = stConstruct(velocities, space = list(values = 1:ncol(velocities)),
time = wind$time, SpatialObj = pts, interval = TRUE)
class(wind.data)
# Obtain country boundaries from package maps ####
library(maptools)
m = map2SpatialLines(map("worldHires", xlim = c(-11,-5.4), ylim = c(51,55.5), plot=F))
proj4string(m) = "+proj=longlat +datum=WGS84"
m = spTransform(m, utm29)
install.packages("mapdata")
library(maptools)
m = map2SpatialLines(map("worldHires", xlim = c(-11,-5.4), ylim = c(51,55.5), plot=F))
library("mapdata", lib.loc="~/R/win-library/3.1")
library(maptools)
m = map2SpatialLines(map("worldHires", xlim = c(-11,-5.4), ylim = c(51,55.5), plot=F))
proj4string(m) = "+proj=longlat +datum=WGS84"
m = spTransform(m, utm29)
grd = SpatialPixels(SpatialPoints(makegrid(m, n = 300)),
proj4string = proj4string(m))
wind.data = wind.data[, "1961-04"]
n = 10
library(xts)
tgrd = seq(min(index(wind.data)), max(index(wind.data)), length=n)
pred.grd = STF(grd, tgrd)
v = vgmST("separable", space = vgm(1, "Exp", 750000), time = vgm(1, "Exp", 1.5 * 3600 * 24),
sill=0.6)
wind.ST = krigeST(values ~ 1, wind.data, pred.grd, v)
colnames(wind.ST@data) <- "sqrt_speed"
wind.ST = krigeST(values ~ 1, wind.data, pred.grd, v)
colnames(wind.ST@data) <- "sqrt_speed"
layout = list(list("sp.lines", m, col= 'grey' ),
+ list("sp.points", pts, first=F, cex=.5))
layout = list(list("sp.lines", m, col= 'grey' ),
list("sp.points", pts, first=F, cex=.5))
stplot(wind.ST, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
windows()
layout = list(list("sp.lines", m, col= 'grey' ),
list("sp.points", pts, first=F, cex=.5))
stplot(wind.ST, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
eof.data = EOF(wind.data) # spatial, from data values
eof.int = EOF(wind.ST) # spatial, from interpolated or modelled values
eof.xts = EOF(wind.ST, "temporal") # temporal, from interpolated or modelled values
windows()
layout = list(list("sp.lines", m, col= 'grey' ),
list("sp.points", pts, first=F, cex=.5))
stplot(eof.int, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
layout = list(list("sp.lines", m, col= 'grey' ),
list("sp.points", pts, first=F, cex=.5))
stplot(EOF(wind.ST), col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
stplot(eof.data, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
stplot(eof.int, col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
plot(eof.int)
eof.data = EOF(wind.data) # spatial, from data values
eof.int = EOF(wind.ST) # spatial, from interpolated or modelled values
eof.xts = EOF(wind.ST, "temporal") # temporal, from interpolated or modelled values
plot(EOF(wind.ST, "temporal", returnPredictions=FALSE))
plot(EOF(wind.ST, "spatial", returnPredictions=FALSE))
plot(EOF(wind.ST, "spatial", col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
plot(EOF(wind.ST, "spatial", returnPredictions=FALSE), col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
plot(EOF(wind.ST, "spatial", returnPredictions=FALSE), col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
warnings()
stplot(EOF(wind.ST, "spatial", returnPredictions=FALSE), col.regions=brewer.pal(11, "RdBu")[-c(10,11)],
at=seq(-1.375,1,by=.25),
par.strip.text = list(cex=.7), sp.layout = layout)
View(Produc)
View(wind)
View(velocities)
View(eof.xts)
setwd("C:/Users/April/Desktop/MSc project/github/spacetime-vis")
library(lattice)
library(ggplot2)
library(latticeExtra)
library(gridBase)
library(gridExtra)
myTheme <- custom.theme.2(pch=19, cex=0.7,
region=rev(brewer.pal(9, 'YlOrRd')),
symbol = brewer.pal(n=8, name = "Dark2"))
myTheme$strip.background$col='transparent'
myTheme$strip.shingle$col='transparent'
myTheme$strip.border$col='transparent'
xscale.components.custom <- function(...){
ans <- xscale.components.default(...)
ans$top=FALSE
ans}
yscale.components.custom <- function(...){
ans <- yscale.components.default(...)
ans$right=FALSE
ans}
myArgs <- list(as.table=TRUE,
between=list(x=0.5, y=0.2),
xscale.components = xscale.components.custom,
yscale.components = yscale.components.custom)
defaultArgs <- lattice.options()$default.args
lattice.options(default.theme = myTheme,
default.args = modifyList(defaultArgs, myArgs))
##################################################################
## Choropleth maps
##################################################################
##################################################################
## Administrative boundaries
##################################################################
library(sp)
library(maptools)
#old <- setwd(tempdir())
IreMap <- readShapePoly(fn="Ireland choropleth")
Encoding(levels(IreMap$NAME_1)) <- "latin1"
IrePoint <- read.table("Ireland choropleth.txt", header=T)
##################################################################
## Map
##################################################################
library(colorspace)
pdf(file="figs/population.pdf")
quantPal <- rev(heat_hcl(16))
spplot(IreMap["POP"], col='transparent', col.regions=quantPal, xlab="Total Population")
dev.off()
pdf(file="figs/cases.pdf")
quantPal <- rev(heat_hcl(16))
spplot(IreMap["CASES"], col='transparent', col.regions=quantPal, xlab="Total Cases")
dev.off()
pdf(file="figs/cases per pop.pdf")
quantPal <- rev(heat_hcl(16))
spplot(IreMap["Cases.Pop"], col='transparent', col.regions=quantPal, xlab="Cases per 100 000")
dev.off()
pdf(file="figs/case fatality.pdf")
quantPal <- rev(heat_hcl(16))
spplot(IreMap["Case.fatal"], col='transparent', col.regions=quantPal, xlab="Case Fatality Rate")
dev.off()
#### Propotional point mapping #####
pdf(file="figs/proportional mortality.pdf")
quantPal <- rev(terrain_hcl(1))
spplot(IreMap["POP"], col='transparent', col.regions=quantPal)
airPal <- colorRampPalette(c('springgreen1', 'sienna3', 'gray5'))(5)
spplot(IrePoint["Rate.of.mo"], col.regions=airPal, cex=sqrt(1:5), add=TRUE, edge.col='black', scales=list(draw=TRUE), key.space='right')
dev.off()
#### Olaf's style ######
library(maptools)
library(spdep)
head(IrePoint)
IrePoint$inc <- 100000*(IrePoint$CASES) / (IrePoint$POP + 1)
Bayes.IrePoint <- EBest((IrePoint$CASES), (IrePoint$POP + 1))
windows()
boxplot(100000*Bayes.IrePoint, col="blue")
IrePoint$sinc <- Bayes.IrePoint$estmm*100000
qtls <- quantile (IrePoint$sinc, probs=seq(0,1,0.20))
IrePoint$cols <- findInterval(IrePoint$sinc, qtls, all.inside=T)
colours <- rev(heat_hcl(5))
#colours <- c(colours[16:1])
windows()
plot(IreMap, axes=T, #xlab="Easting", ylab="Northing",
col=colours[IrePoint$cols])
brks <- round (qtls,1)
min(brks); max(brks); leglabs(brks)
#[1] 0
#[1] 8562.5
#[1] "under 0"         "0 - 1222"        "1222 - 2651.4"   "2651.4 - 3598.7" "over 3598.7"
my.legend <- c("under 91.1","91.1 - 1311","1311 - 2720.2","2720.2 - 3592.6", "3592.6 - 8562.5")
legend(x= -10.8, y = 55.9, legend = my.legend[5:1], cex=0.8, title= " Cases of cholera per 100 000", fill=colours[5:1])
#pdf(file="figs/cases per pop.pdf")
#windows()
#quantPal <- rev(heat_hcl(16))
#spplot(IreMap["Cases.Pop"], col=colours[IreMap$cols], col.regions=quantPal)
dev.off()
###### Models ######
library(maptools)
library(spdep)
#IreTown <- readShapeSpatial(fn="Towns point data")
##### Model morbidity by first day of outbreak #####
#### Poisson count regression ####
First.day.glm <- glm(No..of.cas ~ Day.of.fir + offset(log(Total.popu)), family=poisson, data=IreTown)
summary(First.day.glm)
#Call:
#  glm(formula = No..of.cas ~ Day.of.fir + offset(log(Total.popu)),
#      family = poisson, data = IreTown)
#
#Deviance Residuals:
#  Min       1Q   Median       3Q      Max
#-24.310  -11.130   -6.794    2.993   59.228
#
#Coefficients:
#  Estimate Std. Error z value Pr(>|z|)
#(Intercept) -3.999e+00  1.032e-02 -387.56   <2e-16 ***
#  Day.of.fir   4.002e-03  7.791e-05   51.36   <2e-16 ***
#  ---
#  Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#(Dispersion parameter for poisson family taken to be 1)
#
#Null deviance: 27293  on 135  degrees of freedom
#Residual deviance: 24796  on 134  degrees of freedom
#AIC: 25485
#
#Number of Fisher Scoring iterations: 5
# 24796/134
# overdispersion is present
#### Spatial generalized linear mixed models #####
library(geoR)
test<- as.geodata(cbind(as.data.frame(coordinates(IreMap)), IrePoint$inc))
windows()
plot.geodata(test)
IrePoint$east <- coordinates(IreMap) [,1]
IrePoint$north <- coordinates(IreMap) [,2]
##### Set up a spatial correlation structure #####
attach(IrePoint)
library(MASS)
library(nlme)
spcor <- corSpatial (form= ~ east + north, type="exponential")
ispcor <- Initialize(spcor, data = IrePoint)
#### Spatial Generalized Linear Mixed Model ####
Mortality.glmm<- glmmPQL(CASES ~ north + east + offset(log(POP + 1)), random= ~1 | ID_1, correlation = ispcor, family=poisson)
summary(Mortality.glmm)
setwd("C:/Users/April/Desktop/MSc project/github/spacetime-vis")
##### Cholera risk map ####
library(geoR)
IrePoint$Bayes.Cases <- EBest(IrePoint$CASES, IrePoint$POP + 1) [,"estmm"]
IreMap.geo <- as.geodata(cbind(IrePoint$east, IrePoint$north, IrePoint$Bayes.Cases))
windows()
plot.geodata(IreMap.geo)
win.graph(width = 6, height = 3, pointsize = 12)
par (mfrow=c(1,2), pty="s")
IreMap.svc <- variog(IreMap.geo, estimator.type = "modulus", op="cloud")
plot(IreMap.svc)
IreMap.esv <- variog(IreMap.geo, estimator.type = "modulus")
plot(IreMap.esv)
#### model-based kriging #####
IreMap.esv2 <- variog(IreMap.geo, estimator.type="modulus", max.dist = 2.5)
windows()
plot(IreMap.esv2)
IreMap.beta <- likfit(IreMap.geo, ini.cov.pars=c(0.05, 100000), trend = "cte", fix.nug=TRUE, cov.model="exponential")
lines.variomodel(IreMap.beta, lty=1, lwd=2, max.dist=2.5, col="red")
IreMap.beta
# likfit: estimated model parameters:
# beta  sigmasq      phi
# "0.0240" "0.0004" "0.2274"
# Practical Range with cor=0.05 for asymptotic range: 0.6812445
#
# likfit: maximised log-likelihood = 130.3
library(rgdal)
library(gstat)
Ire.bdr <- read.table(file.choose(), header=T)
Ire.ply <- as.matrix(cbind(Ire.bdr$x, Ire.bdr$y))
plot(Ire.ply)
#Ire.bound1 <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Poly to line3")
#Ire.bound <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Ireland superfile")
#require(maptools)
krige.grid <- expand.grid(seq(min(Ire.bdr$x), max(Ire.bdr$x), l=100), seq(min(Ire.bdr$y), max(Ire.bdr$y), l=100))
#Ire.grid <- spsample(Ire.bound1, type="regular", n=1000, #cellsize=0.1,
#offset = c(0.5, 0.5))
windows()
plot(krige.grid)
Ire.uk <- krige.conv(IreMap.geo, krige = krige.control (type.krige = "ok", trend.d = "cte", obj.model = IreMap.beta), locations = krige.grid, borders = Ire.ply)
win.graph()
Ire.predict <- Ire.uk
Ire.predict$predict <- -Ire.predict$predict
image(Ire.predict, krige.grid, col = heat.colors(10))
Ire.100.predict <- Ire.uk
Ire.100.predict$predict <- 100*Ire.100.predict$predict
contour(Ire.100.predict, labcex=1.2, method = "edge", ad=T)
#my.legend <- c("1%","2%","3%","4%","5%", "6%", "7%", "8%", "9%", "10%")
#legend(x= -10.4, y = 55.6, legend = my.legend[10:1], ncol = 2, cex=0.8, title= " Predicted % cholera risk", fill= heat.colors(10))
##### Mortality risk map ######
library(geoR)
IrePoint$Bayes.Deaths <- EBest(IrePoint$DEATHS, IrePoint$POP + 1) [,"estmm"]
IreMap.geo <- as.geodata(cbind(IrePoint$east, IrePoint$north, IrePoint$Bayes.Deaths))
windows()
plot.geodata(IreMap.geo)
win.graph(width = 6, height = 3, pointsize = 12)
par (mfrow=c(1,2), pty="s")
IreMap.svc <- variog(IreMap.geo, estimator.type = "modulus", op="cloud")
plot(IreMap.svc)
IreMap.esv <- variog(IreMap.geo, estimator.type = "modulus")
plot(IreMap.esv)
#### model-based kriging #####
IreMap.esv2 <- variog(IreMap.geo, estimator.type="modulus", max.dist = 2.5)
windows()
plot(IreMap.esv2)
IreMap.beta <- likfit(IreMap.geo, ini.cov.pars=c(0.05, 100000), trend = "cte", fix.nug=TRUE, cov.model="exponential")
#IreMap.beta <- likfit(IreMap.geo, ini.cov.pars=c(1.0, 100000), trend = "cte", fix.nug=TRUE, cov.model="exponential")
lines.variomodel(IreMap.beta, lty=1, lwd=2, max.dist=2.5, col="red")
IreMap.beta
#likfit: estimated model parameters:
#  beta  sigmasq      phi
#"0.0112" "0.0001" "0.4801"
#Practical Range with cor=0.05 for asymptotic range: 1.43824
#
#likfit: maximised log-likelihood = 183
library(rgdal)
library(gstat)
Ire.bdr <- read.table(file.choose(), header=T) # C:\Users\April\Desktop\MSc project\github\spacetime-vis\ireland_boundary_monster_out (2)
Ire.ply <- as.matrix(cbind(Ire.bdr$x, Ire.bdr$y))
plot(Ire.ply)
#Ire.bound1 <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Poly to line3")
#Ire.bound <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Ireland superfile")
#require(maptools)
krige.grid <- expand.grid(seq(min(Ire.bdr$x), max(Ire.bdr$x), l=100), seq(min(Ire.bdr$y), max(Ire.bdr$y), l=100))
#Ire.grid <- spsample(Ire.bound1, type="regular", n=1000, #cellsize=0.1,
#offset = c(0.5, 0.5))
windows()
plot(krige.grid)
Ire.uk <- krige.conv(IreMap.geo, krige = krige.control (type.krige = "ok", trend.d = "cte", obj.model = IreMap.beta), locations = krige.grid, borders = Ire.ply)
win.graph()
Ire.predict <- Ire.uk
Ire.predict$predict <- -Ire.predict$predict
image(Ire.predict, krige.grid, col = heat.colors(10))
Ire.100.predict <- Ire.uk
Ire.100.predict$predict <- 100*Ire.100.predict$predict
contour(Ire.100.predict, labcex=1.2, method = "edge", ad=T)
#my.legend <- c("0.5%","1.0%","1.5%","2.0%","2.5%", "3.0%", "3.5%", "4.0%", "4.5%", "5.0%")
#legend(x= -10.4, y = 55.6, legend = my.legend[10:1], ncol = 2, cex=0.8, title= " Predicted % mortality risk", fill= heat.colors(10))
###### Case fatality map #####
library(geoR)
IrePoint$Bayes.Casefat <- EBest(IrePoint$DEATHS, IrePoint$CASES) [,"estmm"]
IreMap.geo <- as.geodata(cbind(IrePoint$east, IrePoint$north, IrePoint$Bayes.Casefat))
windows()
plot.geodata(IreMap.geo)
win.graph(width = 6, height = 3, pointsize = 12)
par (mfrow=c(1,2), pty="s")
IreMap.svc <- variog(IreMap.geo, estimator.type = "modulus", op="cloud")
plot(IreMap.svc)
IreMap.esv <- variog(IreMap.geo, estimator.type = "modulus")
plot(IreMap.esv)
#### model-based kriging #####
IreMap.esv2 <- variog(IreMap.geo, estimator.type="modulus", max.dist = 2.5)
windows()
plot(IreMap.esv2)
IreMap.beta <- likfit(IreMap.geo, ini.cov.pars=c(0.05, 100000), trend = "cte", fix.nug=TRUE, cov.model="exponential")
#IreMap.beta <- likfit(IreMap.geo, ini.cov.pars=c(1.0, 100000), trend = "cte", fix.nug=TRUE, cov.model="exponential")
lines.variomodel(IreMap.beta, lty=1, lwd=2, max.dist=2.5, col="red")
IreMap.beta
#likfit: estimated model parameters:
#  beta  sigmasq      phi
#"0.4424" "0.0038" "0.2705"
#Practical Range with cor=0.05 for asymptotic range: 0.8104928
#
#likfit: maximised log-likelihood = 75.32
library(rgdal)
library(gstat)
Ire.bdr <- read.table(file.choose(), header=T) # C:\Users\April\Desktop\MSc project\github\spacetime-vis\ireland_boundary_monster_out (2)
Ire.ply <- as.matrix(cbind(Ire.bdr$x, Ire.bdr$y))
plot(Ire.ply)
#Ire.bound1 <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Poly to line3")
#Ire.bound <- readOGR(dsn="C:/Users/April/Desktop/MSc project/github/spacetime-vis", layer="Ireland superfile")
#require(maptools)
krige.grid <- expand.grid(seq(min(Ire.bdr$x), max(Ire.bdr$x), l=100), seq(min(Ire.bdr$y), max(Ire.bdr$y), l=100))
#Ire.grid <- spsample(Ire.bound1, type="regular", n=1000, #cellsize=0.1,
#offset = c(0.5, 0.5))
windows()
plot(krige.grid)
Ire.uk <- krige.conv(IreMap.geo, krige = krige.control (type.krige = "ok", trend.d = "cte", obj.model = IreMap.beta), locations = krige.grid, borders = Ire.ply)
win.graph()
Ire.predict <- Ire.uk
Ire.predict$predict <- -Ire.predict$predict
image(Ire.predict, krige.grid, col = heat.colors(10))
Ire.100.predict <- Ire.uk
Ire.100.predict$predict <- 100*Ire.100.predict$predict
contour(Ire.100.predict, labcex=1.2, method = "edge", ad=T)
#my.legend <- c("35%","40%","45%","50%","55%", "60%", "65%", "70%", "75%", "80%")
#legend(x= -10.4, y = 55.6, legend = my.legend[10:1], ncol = 2, cex=0.8, title= " Predicted % case fatality risk", fill= heat.colors(10))
setwd("C:/Users/April/Desktop/MSc project/github/spacetime-vis")
library(maptools)
library(spdep)
IreMap <- readShapeSpatial(fn="Ireland choropleth")
plot(IreMap, border = "black", lwd = 1)
Ire.nb <- poly2nb(IreMap, queen = FALSE)
str(Ire.nb)
coordinates(IreMap)
text(coordinates(IreMap), labels=c(1:51), cex=0.8)
# generate distance based neighbourhoods of 50km and 100km and 120km
# Ire.nb.20km <- dnearneigh(coordinates(IreMap), d1 = 0, d2 = 20000, longlat=NULL)
# Ire.nb.50km <- dnearneigh(coordinates(IreMap), d1 = 0, d2 = 50000, longlat=NULL)
# Ire.nb.100km <- dnearneigh(coordinates(IreMap), d1 = 0, d2 = 100000, longlat=NULL)
# Ire.nb.120km <- dnearneigh(coordinates(IreMap), d1 = 0, d2 = 120000, longlat=NULL)
##### Analysis of disease clustering with regional data #####
IrePoint <- read.table("Ireland choropleth.txt", header=T)
names(IrePoint)
#[1] "ID_1"       "NAME_1"     "POP"        "CASES"      "DEATHS"     "Cases.Pop"  "Case_fatal"
my.dat <- as.data.frame(coordinates(IreMap))
names(my.dat) <- c("x", "y")
my.dat$POP <- IrePoint$POP
my.dat$CASES <- IrePoint$CASES
my.dat$raw <- my.dat$CASES / (my.dat$POP + 1)
#library(stats)
#na.fail(my.dat$raw)
moran.test(my.dat$raw, nb2listw(Ire.nb), alternative = "two.sided")
# Moran's I test under randomisation
#
# data:  my.dat$raw
# weights: nb2listw(Ire.nb)
#
# Moran I statistic standard deviate = 3.4118, p-value = 0.0006454
# alternative hypothesis: two.sided
# sample estimates:
# Moran I statistic       Expectation          Variance
#      0.294231547      -0.019607843       0.008461517
#### Smoothing #####
Cluster.smooth <- EBest(my.dat$CASES, my.dat$POP + 1, family="binomial")
my.dat$raw <- Cluster.smooth$raw
my.dat$estmm <- Cluster.smooth$estmm
head(my.dat)
moran.test(my.dat$estmm, nb2listw(Ire.nb), alternative = "two.sided")
# Moran's I test under randomisation
#
# data:  my.dat$estmm
# weights: nb2listw(Ire.nb)
#
# Moran I statistic standard deviate = 3.1921, p-value = 0.001412
# alternative hypothesis: two.sided
# sample estimates:
# Moran I statistic       Expectation          Variance
#      0.273829622      -0.019607843       0.008450203
geary.test(my.dat$raw, nb2listw(Ire.nb))
geary.test(my.dat$estmm, nb2listw(Ire.nb))
# Geary's C test under randomisation
#
# data:  my.dat$estmm
# weights: nb2listw(Ire.nb)
#
# Geary C statistic standard deviate = 2.8428, p-value = 0.002236
# alternative hypothesis: Expectation greater than statistic
# sample estimates:
# Geary C statistic       Expectation          Variance
#      0.716519425       1.000000000       0.009943568
##### how far observations are dependent ####
Ire.acf <- sp.correlogram(Ire.nb, my.dat$estmm, order=6, method="I", zero.policy=TRUE)
print(Ire.acf)
plot(Ire.acf)
##### ANALYSIS OF DISEASE CLUSTERING WITH SPATIAL POINT PATTERN DATA ########
pts <- read.table("IRE-SPP.txt", header=T)
ptsp <- pts[pts$CASES >= 1,]
ptsn <- pts[pts$CASES == 0,]
case <- list (x=ptsp$x , y=ptsp$y)
cont <- list(x=ptsn$x, y=ptsn$y)
Nrep <- 999
k <- (1:15)
out <- TangoCNN.index(case, cont, s=k, Nrep)
out$p.value
# [1] 0.007
######## D-function #######
plot(runif(50, min=0, max=1), runif(50, min=0, max=1), pch=16, col="blue")
pts <- read.table("IRE-SPP.txt", header=T)
ptsp <- pts[pts$CASES >= 1,]
ptsn <- pts[pts$CASES == 0,]
library(maptools)
IreMap <- readShapeSpatial(fn="Ireland choropleth")
plot(IreMap)
points(ptsn$x , ptsn$y, cex=0.6, pch=16, col="blue")
points(ptsp$x , ptsp$y, cex=0.6, pch=16, col="red")
### Transform the data into points object ####
library(splancs)
pts.p <- as.points(ptsp$x, ptsp$y)
pts.n <- as.points(ptsn$x, ptsn$y)
pts.all <- as.points(pts$x, pts$y)
pts.poly <- read.table(file.choose(), header=T)
Ire.bdr <- read.table(file.choose(), header=T) # C:\Users\April\Desktop\MSc project\github\spacetime-vis\ireland_boundary_monster_out (2)
#### Estimate k-functions #####
s <- seq(from=0, to=150000, length=21)
pts.poly <- as.points(pts.poly)
#Kpos <- khat(pts.p, pts.poly, s)
?khat
